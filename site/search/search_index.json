{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>Welcome to the official home of documentation for the GRIDmas Tree project. On this site you will find all the information that you will need to make your own customised designs and patterns for the Tree.</p> <p>This is a project based on Standup Maths' 500 LED christmas tree Watch Here</p>"},{"location":"#how-to-run","title":"How To Run","text":"<p>To run this project you must have <code>Python</code> installed on your system.</p>"},{"location":"#downloading","title":"Downloading","text":"<p>To download the Gridmas tree code you can either use the github Desktop app to clone the code or use git from the terminal as below</p> <pre><code>git clone https://github.com/COOK1EK1W1/gridmas-tree.git\n</code></pre>"},{"location":"#setup","title":"Setup","text":"<p>The project comes with a virtual environment (venv) setup script. Using this is optional but recommended.</p>"},{"location":"#venv","title":"Venv","text":"<p>To set up a venv, run the following commands. If you are not setting up a venv, proceed to Installing Modules</p>"},{"location":"#windows","title":"Windows","text":"<pre><code>venv/Scripts/activate.bat\n</code></pre>"},{"location":"#linux","title":"Linux","text":"<pre><code>source venv/Scripts/activate\n</code></pre>"},{"location":"#mac","title":"Mac","text":"<pre><code>source venv/Scripts/activate\n</code></pre>"},{"location":"#installing-modules","title":"Installing Modules","text":"<p>To install the modules required for the project to work run the following command</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"#running","title":"Running","text":"<p>Now that the project has been setup, you are ready to run it.</p> <p>To run the tree simulator, run the following commands</p> <pre><code>cd backend\n\npython main.py\n</code></pre> <p>This will start the webserver, and - assuming that you don't have 1000 LEDs connected, because who doesn't? - will start the tree simulator program.</p> <p>Once the webserver is up and running, you should be able to access the tree controller at This address. (http://localhost:3000)</p>"},{"location":"attributes/","title":"Attributes","text":"<p>Attributes allow you to change parameters of your pattern while the pattern is running from the web interface, this helps create more dynamic and customizable patterns</p>"},{"location":"attributes/#backend.attribute.Attribute","title":"<code>Attribute</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Only initialise attributes once in the run function</p> Source code in <code>backend\\attribute.py</code> <pre><code>class Attribute(Generic[T], ABC):\n    \"\"\"Only initialise attributes once in the run function\n    \"\"\"\n\n    def __init__(self, name: str, value: T):\n        self.name = name\n        self.value: T = value\n\n    def get(self) -&gt; T:\n        \"\"\"Get the current value of the attribute\n\n        Returns:\n            T: The value of the attribute\n        \"\"\"\n        return self.value\n\n    def set(self, value: T):\n        \"\"\"Set the value of the range.\n\n           The use of this is discouraged in a pattern\n\n        Args:\n            value (T): The value to set the attribute to\n        \"\"\"\n        self.value = value\n\n    @abstractmethod\n    def pattern_string(self) -&gt; str:\n        ...\n</code></pre>"},{"location":"attributes/#backend.attribute.Attribute.get","title":"<code>get()</code>","text":"<p>Get the current value of the attribute</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The value of the attribute</p> Source code in <code>backend\\attribute.py</code> <pre><code>def get(self) -&gt; T:\n    \"\"\"Get the current value of the attribute\n\n    Returns:\n        T: The value of the attribute\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"attributes/#backend.attribute.Attribute.set","title":"<code>set(value)</code>","text":"<p>Set the value of the range.</p> <p>The use of this is discouraged in a pattern</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to set the attribute to</p> required Source code in <code>backend\\attribute.py</code> <pre><code>def set(self, value: T):\n    \"\"\"Set the value of the range.\n\n       The use of this is discouraged in a pattern\n\n    Args:\n        value (T): The value to set the attribute to\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"attributes/#backend.attribute.ColorAttr","title":"<code>ColorAttr</code>","text":"<p>               Bases: <code>Attribute[Color]</code></p> Source code in <code>backend\\attribute.py</code> <pre><code>class ColorAttr(Attribute[Color]):\n    def __init__(self, name: str, value: Color):\n        \"\"\"Used when you want to accept a color as an input\n\n        Args:\n            name (str): The name displayed on the interface\n            value (Color): The initial starting color\n        \"\"\"\n        super().__init__(name, value)\n        Store.get_store().add(self)\n\n    def pattern_string(self):\n        return \"ColorAttr.html\"\n</code></pre>"},{"location":"attributes/#backend.attribute.ColorAttr.__init__","title":"<code>__init__(name, value)</code>","text":"<p>Used when you want to accept a color as an input</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name displayed on the interface</p> required <code>value</code> <code>Color</code> <p>The initial starting color</p> required Source code in <code>backend\\attribute.py</code> <pre><code>def __init__(self, name: str, value: Color):\n    \"\"\"Used when you want to accept a color as an input\n\n    Args:\n        name (str): The name displayed on the interface\n        value (Color): The initial starting color\n    \"\"\"\n    super().__init__(name, value)\n    Store.get_store().add(self)\n</code></pre>"},{"location":"attributes/#backend.attribute.RangeAttr","title":"<code>RangeAttr</code>","text":"<p>               Bases: <code>Attribute[float]</code></p> Source code in <code>backend\\attribute.py</code> <pre><code>class RangeAttr(Attribute[float]):\n    def __init__(self, name: str,\n                 value: float,\n                 min: float,\n                 max: float,\n                 step: float):\n        \"\"\"Used when you want to accept a value from a pre defined range\n\n        Args:\n            name (str): The name displayed on the interface\n            value (float): The default starting value\n            min (float): The minimum value accepted\n            max (float): The maximum value accepted\n            step (float): The resolution for the range\n        \"\"\"\n        self.min = min\n        self.max = max\n        super().__init__(name, float(clamp(value, self.min, self.max)))\n        self.step = step\n        Store.get_store().add(self)\n\n    def pattern_string(self):\n        return 'RangeAttr.html'\n</code></pre>"},{"location":"attributes/#backend.attribute.RangeAttr.__init__","title":"<code>__init__(name, value, min, max, step)</code>","text":"<p>Used when you want to accept a value from a pre defined range</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name displayed on the interface</p> required <code>value</code> <code>float</code> <p>The default starting value</p> required <code>min</code> <code>float</code> <p>The minimum value accepted</p> required <code>max</code> <code>float</code> <p>The maximum value accepted</p> required <code>step</code> <code>float</code> <p>The resolution for the range</p> required Source code in <code>backend\\attribute.py</code> <pre><code>def __init__(self, name: str,\n             value: float,\n             min: float,\n             max: float,\n             step: float):\n    \"\"\"Used when you want to accept a value from a pre defined range\n\n    Args:\n        name (str): The name displayed on the interface\n        value (float): The default starting value\n        min (float): The minimum value accepted\n        max (float): The maximum value accepted\n        step (float): The resolution for the range\n    \"\"\"\n    self.min = min\n    self.max = max\n    super().__init__(name, float(clamp(value, self.min, self.max)))\n    self.step = step\n    Store.get_store().add(self)\n</code></pre>"},{"location":"colors/","title":"Colors","text":"<p>Warning</p> <p>I appologise to all british programmers who spell color as colour,  but within the programming world we spell it color.  This will be the cause of 90% of your bugs if you're not use to programming with the color spelling</p> <p>colors is a module which contains class definitions for Color and Pixel as well as  helper functions for converting colors between formats</p> <p>I appologise to all british programmers who spell color as colour, but within the programming world we spell it color. This will be the cause of 90% of your bugs if you're not use to programming with the color spelling</p>"},{"location":"colors/#backend.colors.Color","title":"<code>Color</code>","text":"<p>A class representing a color</p> <p>Attributes: r: int: Red g: int: Green b: int: Blue</p> Source code in <code>backend\\colors.py</code> <pre><code>class Color:\n    \"\"\"A class representing a color\n\n       Attributes:\n       r: int: Red\n       g: int: Green\n       b: int: Blue\n    \"\"\"\n\n    def __init__(self, r: int, g: int, b: int):\n        self.r: int = r &amp; 0xff\n        self.g: int = g &amp; 0xff\n        self.b: int = b &amp; 0xff\n\n        self._L_previous = (0, 0, 0)\n        self._L_target = (0, 0, 0)\n\n        self._L_step = 0\n        self._L_total = 1\n\n        self._L_fn = linear\n\n    def set_rgb(self, r: int, g: int, b: int):\n        \"\"\"Set the red, green and blue values of the color.\n           All params are bounded between 0 and 255\n\n        Args:\n            r (int): Red value: 0 - 255\n            g (int): Green value: 0 - 255\n            b (int): Blue value: 0 - 255\n        \"\"\"\n        self.r = r &amp; 0xff\n        self.g = g &amp; 0xff\n        self.b = b &amp; 0xff\n\n        self.lerp_reset()\n\n    def set_color(self, color: 'Color'):\n        \"\"\"Set the color to another named color.\n\n        Args:\n            color (Color): Named color\n        \"\"\"\n        self.set_rgb(*color.to_tuple())\n\n    def fade(self, n: float = 1.1):\n        \"\"\"Fade the color slightly\n\n        Args:\n            n (float, optional): The greater the value of n, the faster the fade will progress. Values less than 0 cause the color to get brighter to a max color of white. Defaults to 1.1.\n        \"\"\"\n        self.r = int(clamp(self.r / n, 0, 255))\n        self.g = int(clamp(self.g / n, 0, 255))\n        self.b = int(clamp(self.b / n, 0, 255))\n\n        self.lerp_reset()\n\n    def to_hex(self) -&gt; str:\n        \"\"\"Returns the hex value of an RGB color\n\n        Returns:\n            str: The hex value of the color\n        \"\"\"\n        return tuple2hex((self.r, self.g, self.b))\n\n    def to_tuple(self) -&gt; tuple[int, int, int]:\n        \"\"\"Returns the tuple of the R, G and B values between 0 and 255\n\n        Returns:\n            tuple[int, int, int]: [Red, Green, Blue]\n        \"\"\"\n        return (self.r, self.g, self.b)\n\n    def to_int(self) -&gt; int:\n        \"\"\"Return the color as an integer\n\n        Returns:\n            int: Color represented as an integer\n        \"\"\"\n        return (self.r &lt;&lt; 8) | (self.g &lt;&lt; 16) | self.b\n\n    def lerp_reset(self):\n        self._L_previous = (self.r, self.g, self.b)\n        self._L_step = 0\n\n    def lerp(self, target: tuple[int, int, int], time: int, override: bool = False, fn: Callable[[float], float] = linear):\n        \"\"\"Linearly interpolate the color from its current color to the target color\n\n        Args:\n            target (tuple[int, int, int]): The target color\n            time (int): The time taken for the lerp to complete\n            override (bool, optional): If set to true, the lerp will only progress when you call lerp again. Defaults to False.\n            fn (Callable[[float], float], optional): Timing function from the Util module. Defaults to linear.\n        \"\"\"\n        self.set_lerp(target, time, override, fn)\n        self.cont_lerp()\n\n    def set_lerp(self, target: tuple[int, int, int], time: int, override: bool = False, fn: Callable[[float], float] = linear):\n        \"\"\"This resets the lerp and starts interpolation to the target from the current value.\n\n        Args:\n            target (tuple[int, int, int]): Target color\n            time (int): Time taken to complete the lerp\n            override (bool, optional): If true, the target can be changed while the lerp is in progress. Defaults to False.\n            fn (Callable[[float], float], optional): Timing function from the Util module. Defaults to linear.\n        \"\"\"\n        if (target != self._L_target or self._L_total != time) or override:\n            self.lerp_reset()\n            self._L_target = target\n            self._L_total = time\n            self._L_fn = fn\n\n    def cont_lerp(self):\n        \"\"\"Advanced the lerp one step.\n        \"\"\"\n        if self._L_step == self._L_total:\n            return\n        self._L_step = min(self._L_step + 1, self._L_total)\n        percent = clamp(self._L_step / self._L_total, 0, 1)\n        d = self._L_fn(percent)\n\n        self.r = int(self._L_previous[0] * (1 - d) + self._L_target[0] * d)\n        self.g = int(self._L_previous[1] * (1 - d) + self._L_target[1] * d)\n        self.b = int(self._L_previous[2] * (1 - d) + self._L_target[2] * d)\n\n    @staticmethod\n    def from_hex(s: str) -&gt; 'Color':\n        \"\"\"Get a color from a string hex code\n\n        Args:\n            s (str): The hex color\n\n        Returns:\n            Color: (r,g,b) repsentation of the color\n        \"\"\"\n        return Color(int(s[1:3], 16), int(s[3:5], 16), int(s[5:7], 16))\n\n    @staticmethod\n    def from_hsl(hue: float, sat: float, lig: float) -&gt; 'Color':\n        \"\"\"Get a color from hsl format\n\n        Args:\n            hue (float): The hue of the target color\n            sat (float): The saturation of the target color\n            lig (float): The lightness of the target color\n\n        Returns:\n            Color: (r,g,b) repsentation of the color\n        \"\"\"\n        r, g, b = colorsys.hsv_to_rgb(hue, sat, lig)\n        return Color(int(r * 255), int(g * 255), int(b * 255))\n\n    @staticmethod\n    def white() -&gt; 'Color':\n        \"\"\"The color white\n\n        Returns:\n            Color: White\n        \"\"\"\n        return Color(255, 255, 255)\n\n    @staticmethod\n    def black() -&gt; 'Color':\n        \"\"\"The color black. Since LED's can't be black. This is equivalent to off.\n\n        Returns:\n            Color: Black\n        \"\"\"\n        return Color(0, 0, 0)\n\n    @staticmethod\n    def red() -&gt; 'Color':\n        \"\"\"The color red\n\n        Returns:\n            Color: Red\n        \"\"\"\n        return Color(255, 0, 0)\n\n    @staticmethod\n    def green() -&gt; 'Color':\n        \"\"\"The color green\n\n        Returns:\n            Color: Green\n        \"\"\"\n        return Color(0, 255, 0)\n\n    @staticmethod\n    def blue() -&gt; 'Color':\n        \"\"\"The color blue\n\n        Returns:\n            Color: Blue\n        \"\"\"\n        return Color(0, 0, 255)\n\n    @staticmethod\n    def random(saturation: float = 1, lightness: float = 0.6) -&gt; 'Color':\n        \"\"\"Generate a random color.\n           The random value is for the Hue. The saturation and lightness can be specified\n\n        Args:\n            saturation (float, optional): The target saturation. Defaults to 1.\n            lightness (float, optional): The target lightness. Defaults to 0.6.\n\n        Returns:\n            Color: The color that is generated\n        \"\"\"\n        return Color.from_hsl(random.random(), saturation, lightness)\n\n    @staticmethod\n    def different_from(color: 'Color') -&gt; 'Color':\n        \"\"\"Generate a random color which is different from the color passed into it, maintaining the same hue and saturation\n\n        Args:\n            color (Color): The color which is currently in use\n\n        Returns:\n            Color: A color which is different from the one passed into the function\n        \"\"\"\n        h, s, v = colorsys.rgb_to_hsv(*color.to_tuple())\n        newh = ((h * 360 + random.randint(0, 180) + 40) % 360) / 360\n        nr, ng, nb = colorsys.hsv_to_rgb(newh, s, v)\n        return Color(int(nr), int(ng), int(nb))\n</code></pre>"},{"location":"colors/#backend.colors.Color.black","title":"<code>black()</code>  <code>staticmethod</code>","text":"<p>The color black. Since LED's can't be black. This is equivalent to off.</p> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>Black</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef black() -&gt; 'Color':\n    \"\"\"The color black. Since LED's can't be black. This is equivalent to off.\n\n    Returns:\n        Color: Black\n    \"\"\"\n    return Color(0, 0, 0)\n</code></pre>"},{"location":"colors/#backend.colors.Color.blue","title":"<code>blue()</code>  <code>staticmethod</code>","text":"<p>The color blue</p> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>Blue</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef blue() -&gt; 'Color':\n    \"\"\"The color blue\n\n    Returns:\n        Color: Blue\n    \"\"\"\n    return Color(0, 0, 255)\n</code></pre>"},{"location":"colors/#backend.colors.Color.cont_lerp","title":"<code>cont_lerp()</code>","text":"<p>Advanced the lerp one step.</p> Source code in <code>backend\\colors.py</code> <pre><code>def cont_lerp(self):\n    \"\"\"Advanced the lerp one step.\n    \"\"\"\n    if self._L_step == self._L_total:\n        return\n    self._L_step = min(self._L_step + 1, self._L_total)\n    percent = clamp(self._L_step / self._L_total, 0, 1)\n    d = self._L_fn(percent)\n\n    self.r = int(self._L_previous[0] * (1 - d) + self._L_target[0] * d)\n    self.g = int(self._L_previous[1] * (1 - d) + self._L_target[1] * d)\n    self.b = int(self._L_previous[2] * (1 - d) + self._L_target[2] * d)\n</code></pre>"},{"location":"colors/#backend.colors.Color.different_from","title":"<code>different_from(color)</code>  <code>staticmethod</code>","text":"<p>Generate a random color which is different from the color passed into it, maintaining the same hue and saturation</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color</code> <p>The color which is currently in use</p> required <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>A color which is different from the one passed into the function</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef different_from(color: 'Color') -&gt; 'Color':\n    \"\"\"Generate a random color which is different from the color passed into it, maintaining the same hue and saturation\n\n    Args:\n        color (Color): The color which is currently in use\n\n    Returns:\n        Color: A color which is different from the one passed into the function\n    \"\"\"\n    h, s, v = colorsys.rgb_to_hsv(*color.to_tuple())\n    newh = ((h * 360 + random.randint(0, 180) + 40) % 360) / 360\n    nr, ng, nb = colorsys.hsv_to_rgb(newh, s, v)\n    return Color(int(nr), int(ng), int(nb))\n</code></pre>"},{"location":"colors/#backend.colors.Color.fade","title":"<code>fade(n=1.1)</code>","text":"<p>Fade the color slightly</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The greater the value of n, the faster the fade will progress. Values less than 0 cause the color to get brighter to a max color of white. Defaults to 1.1.</p> <code>1.1</code> Source code in <code>backend\\colors.py</code> <pre><code>def fade(self, n: float = 1.1):\n    \"\"\"Fade the color slightly\n\n    Args:\n        n (float, optional): The greater the value of n, the faster the fade will progress. Values less than 0 cause the color to get brighter to a max color of white. Defaults to 1.1.\n    \"\"\"\n    self.r = int(clamp(self.r / n, 0, 255))\n    self.g = int(clamp(self.g / n, 0, 255))\n    self.b = int(clamp(self.b / n, 0, 255))\n\n    self.lerp_reset()\n</code></pre>"},{"location":"colors/#backend.colors.Color.from_hex","title":"<code>from_hex(s)</code>  <code>staticmethod</code>","text":"<p>Get a color from a string hex code</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The hex color</p> required <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>(r,g,b) repsentation of the color</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef from_hex(s: str) -&gt; 'Color':\n    \"\"\"Get a color from a string hex code\n\n    Args:\n        s (str): The hex color\n\n    Returns:\n        Color: (r,g,b) repsentation of the color\n    \"\"\"\n    return Color(int(s[1:3], 16), int(s[3:5], 16), int(s[5:7], 16))\n</code></pre>"},{"location":"colors/#backend.colors.Color.from_hsl","title":"<code>from_hsl(hue, sat, lig)</code>  <code>staticmethod</code>","text":"<p>Get a color from hsl format</p> <p>Parameters:</p> Name Type Description Default <code>hue</code> <code>float</code> <p>The hue of the target color</p> required <code>sat</code> <code>float</code> <p>The saturation of the target color</p> required <code>lig</code> <code>float</code> <p>The lightness of the target color</p> required <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>(r,g,b) repsentation of the color</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef from_hsl(hue: float, sat: float, lig: float) -&gt; 'Color':\n    \"\"\"Get a color from hsl format\n\n    Args:\n        hue (float): The hue of the target color\n        sat (float): The saturation of the target color\n        lig (float): The lightness of the target color\n\n    Returns:\n        Color: (r,g,b) repsentation of the color\n    \"\"\"\n    r, g, b = colorsys.hsv_to_rgb(hue, sat, lig)\n    return Color(int(r * 255), int(g * 255), int(b * 255))\n</code></pre>"},{"location":"colors/#backend.colors.Color.green","title":"<code>green()</code>  <code>staticmethod</code>","text":"<p>The color green</p> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>Green</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef green() -&gt; 'Color':\n    \"\"\"The color green\n\n    Returns:\n        Color: Green\n    \"\"\"\n    return Color(0, 255, 0)\n</code></pre>"},{"location":"colors/#backend.colors.Color.lerp","title":"<code>lerp(target, time, override=False, fn=linear)</code>","text":"<p>Linearly interpolate the color from its current color to the target color</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>tuple[int, int, int]</code> <p>The target color</p> required <code>time</code> <code>int</code> <p>The time taken for the lerp to complete</p> required <code>override</code> <code>bool</code> <p>If set to true, the lerp will only progress when you call lerp again. Defaults to False.</p> <code>False</code> <code>fn</code> <code>Callable[[float], float]</code> <p>Timing function from the Util module. Defaults to linear.</p> <code>linear</code> Source code in <code>backend\\colors.py</code> <pre><code>def lerp(self, target: tuple[int, int, int], time: int, override: bool = False, fn: Callable[[float], float] = linear):\n    \"\"\"Linearly interpolate the color from its current color to the target color\n\n    Args:\n        target (tuple[int, int, int]): The target color\n        time (int): The time taken for the lerp to complete\n        override (bool, optional): If set to true, the lerp will only progress when you call lerp again. Defaults to False.\n        fn (Callable[[float], float], optional): Timing function from the Util module. Defaults to linear.\n    \"\"\"\n    self.set_lerp(target, time, override, fn)\n    self.cont_lerp()\n</code></pre>"},{"location":"colors/#backend.colors.Color.random","title":"<code>random(saturation=1, lightness=0.6)</code>  <code>staticmethod</code>","text":"<p>Generate a random color.    The random value is for the Hue. The saturation and lightness can be specified</p> <p>Parameters:</p> Name Type Description Default <code>saturation</code> <code>float</code> <p>The target saturation. Defaults to 1.</p> <code>1</code> <code>lightness</code> <code>float</code> <p>The target lightness. Defaults to 0.6.</p> <code>0.6</code> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>The color that is generated</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef random(saturation: float = 1, lightness: float = 0.6) -&gt; 'Color':\n    \"\"\"Generate a random color.\n       The random value is for the Hue. The saturation and lightness can be specified\n\n    Args:\n        saturation (float, optional): The target saturation. Defaults to 1.\n        lightness (float, optional): The target lightness. Defaults to 0.6.\n\n    Returns:\n        Color: The color that is generated\n    \"\"\"\n    return Color.from_hsl(random.random(), saturation, lightness)\n</code></pre>"},{"location":"colors/#backend.colors.Color.red","title":"<code>red()</code>  <code>staticmethod</code>","text":"<p>The color red</p> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>Red</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef red() -&gt; 'Color':\n    \"\"\"The color red\n\n    Returns:\n        Color: Red\n    \"\"\"\n    return Color(255, 0, 0)\n</code></pre>"},{"location":"colors/#backend.colors.Color.set_color","title":"<code>set_color(color)</code>","text":"<p>Set the color to another named color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color</code> <p>Named color</p> required Source code in <code>backend\\colors.py</code> <pre><code>def set_color(self, color: 'Color'):\n    \"\"\"Set the color to another named color.\n\n    Args:\n        color (Color): Named color\n    \"\"\"\n    self.set_rgb(*color.to_tuple())\n</code></pre>"},{"location":"colors/#backend.colors.Color.set_lerp","title":"<code>set_lerp(target, time, override=False, fn=linear)</code>","text":"<p>This resets the lerp and starts interpolation to the target from the current value.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>tuple[int, int, int]</code> <p>Target color</p> required <code>time</code> <code>int</code> <p>Time taken to complete the lerp</p> required <code>override</code> <code>bool</code> <p>If true, the target can be changed while the lerp is in progress. Defaults to False.</p> <code>False</code> <code>fn</code> <code>Callable[[float], float]</code> <p>Timing function from the Util module. Defaults to linear.</p> <code>linear</code> Source code in <code>backend\\colors.py</code> <pre><code>def set_lerp(self, target: tuple[int, int, int], time: int, override: bool = False, fn: Callable[[float], float] = linear):\n    \"\"\"This resets the lerp and starts interpolation to the target from the current value.\n\n    Args:\n        target (tuple[int, int, int]): Target color\n        time (int): Time taken to complete the lerp\n        override (bool, optional): If true, the target can be changed while the lerp is in progress. Defaults to False.\n        fn (Callable[[float], float], optional): Timing function from the Util module. Defaults to linear.\n    \"\"\"\n    if (target != self._L_target or self._L_total != time) or override:\n        self.lerp_reset()\n        self._L_target = target\n        self._L_total = time\n        self._L_fn = fn\n</code></pre>"},{"location":"colors/#backend.colors.Color.set_rgb","title":"<code>set_rgb(r, g, b)</code>","text":"<p>Set the red, green and blue values of the color.    All params are bounded between 0 and 255</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Red value: 0 - 255</p> required <code>g</code> <code>int</code> <p>Green value: 0 - 255</p> required <code>b</code> <code>int</code> <p>Blue value: 0 - 255</p> required Source code in <code>backend\\colors.py</code> <pre><code>def set_rgb(self, r: int, g: int, b: int):\n    \"\"\"Set the red, green and blue values of the color.\n       All params are bounded between 0 and 255\n\n    Args:\n        r (int): Red value: 0 - 255\n        g (int): Green value: 0 - 255\n        b (int): Blue value: 0 - 255\n    \"\"\"\n    self.r = r &amp; 0xff\n    self.g = g &amp; 0xff\n    self.b = b &amp; 0xff\n\n    self.lerp_reset()\n</code></pre>"},{"location":"colors/#backend.colors.Color.to_hex","title":"<code>to_hex()</code>","text":"<p>Returns the hex value of an RGB color</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The hex value of the color</p> Source code in <code>backend\\colors.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"Returns the hex value of an RGB color\n\n    Returns:\n        str: The hex value of the color\n    \"\"\"\n    return tuple2hex((self.r, self.g, self.b))\n</code></pre>"},{"location":"colors/#backend.colors.Color.to_int","title":"<code>to_int()</code>","text":"<p>Return the color as an integer</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Color represented as an integer</p> Source code in <code>backend\\colors.py</code> <pre><code>def to_int(self) -&gt; int:\n    \"\"\"Return the color as an integer\n\n    Returns:\n        int: Color represented as an integer\n    \"\"\"\n    return (self.r &lt;&lt; 8) | (self.g &lt;&lt; 16) | self.b\n</code></pre>"},{"location":"colors/#backend.colors.Color.to_tuple","title":"<code>to_tuple()</code>","text":"<p>Returns the tuple of the R, G and B values between 0 and 255</p> <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>tuple[int, int, int]: [Red, Green, Blue]</p> Source code in <code>backend\\colors.py</code> <pre><code>def to_tuple(self) -&gt; tuple[int, int, int]:\n    \"\"\"Returns the tuple of the R, G and B values between 0 and 255\n\n    Returns:\n        tuple[int, int, int]: [Red, Green, Blue]\n    \"\"\"\n    return (self.r, self.g, self.b)\n</code></pre>"},{"location":"colors/#backend.colors.Color.white","title":"<code>white()</code>  <code>staticmethod</code>","text":"<p>The color white</p> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>White</p> Source code in <code>backend\\colors.py</code> <pre><code>@staticmethod\ndef white() -&gt; 'Color':\n    \"\"\"The color white\n\n    Returns:\n        Color: White\n    \"\"\"\n    return Color(255, 255, 255)\n</code></pre>"},{"location":"colors/#backend.colors.Pixel","title":"<code>Pixel</code>","text":"<p>               Bases: <code>Color</code></p> <p>The pixel class extends the Color class by adding 3D coordinates to a color. All the same methods and attributes exist on a pixel so they act the same way</p> <p>Coordintates are in the GIFT format so range between -1 and 1 on X and Y axis, and 0 and tree.height on the Z axis</p> <p>Attributes: x: float: The x axis position y: float: The y axis position z: float: The z axis position a: float: The polar angle in radians from the x axis going clockwise when looking downward on the tree d: float: The polar distance from the Z axis (trunk)</p> Source code in <code>backend\\colors.py</code> <pre><code>class Pixel(Color):\n    \"\"\"The pixel class extends the Color class by adding 3D coordinates to a color.\n       All the same methods and attributes exist on a pixel so they act the same way\n\n       Coordintates are in the GIFT format so range between -1 and 1 on X and Y axis,\n       and 0 and tree.height on the Z axis\n\n       Attributes:\n       x: float: The x axis position\n       y: float: The y axis position\n       z: float: The z axis position\n       a: float: The polar angle in radians from the x axis going clockwise when looking downward on the tree\n       d: float: The polar distance from the Z axis (trunk)\n    \"\"\"\n\n    def __init__(self, coord: tuple[float, float, float], color: Color = Color.black()):\n        super().__init__(*color.to_tuple())\n        self.x = coord[0]\n        self.y = coord[1]\n        self.z = coord[2]\n\n        self.a = math.atan2(self.y, self.x)\n        self.d = math.sqrt(self.y ** 2 + self.x ** 2)\n</code></pre>"},{"location":"colors/#backend.colors.hex2tuple","title":"<code>hex2tuple(h)</code>","text":"<p>Convert a hex string to an RGB tuple</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>str</code> <p>Hex string of a color</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>tuple[int, int, int]: RGB tuple of the color</p> Source code in <code>backend\\colors.py</code> <pre><code>def hex2tuple(h: str) -&gt; tuple[int, int, int]:\n    \"\"\"Convert a hex string to an RGB tuple\n\n    Args:\n        h (str): Hex string of a color\n\n    Returns:\n        tuple[int, int, int]: RGB tuple of the color\n    \"\"\"\n    return (int(h[1:3], 16), int(h[3:5], 16), int(h[5:7], 16))\n</code></pre>"},{"location":"colors/#backend.colors.int2tuple","title":"<code>int2tuple(c)</code>","text":"<p>conver the 24bit encoded int to tuple of R, G, and B.</p> <p>int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>int</code> <p>Color represented as an int</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>tuple[int, int, int]: R,G,B bitmap of the input color</p> Source code in <code>backend\\colors.py</code> <pre><code>def int2tuple(c: int) -&gt; tuple[int, int, int]:\n    \"\"\"conver the 24bit encoded int to tuple of R, G, and B.\n\n       int bitmap encoded as GGGGGGGGRRRRRRRRBBBBBBBB\n\n    Args:\n        c (int): Color represented as an int\n\n    Returns:\n        tuple[int, int, int]: R,G,B bitmap of the input color\n    \"\"\"\n    return ((c &gt;&gt; 8) &amp; 0xff, (c &gt;&gt; 16) &amp; 0xff, c &amp; 0xff)\n</code></pre>"},{"location":"colors/#backend.colors.tuple2hex","title":"<code>tuple2hex(t)</code>","text":"<p>Convert an RGB tuple to hex string</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>tuple[int, int, int]</code> <p>RGB color</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hex value of the color</p> Source code in <code>backend\\colors.py</code> <pre><code>def tuple2hex(t: tuple[int, int, int]) -&gt; str:\n    \"\"\"Convert an RGB tuple to hex string\n\n    Args:\n        t (tuple[int, int, int]): RGB color\n\n    Returns:\n        str: Hex value of the color\n    \"\"\"\n    return '#%02x%02x%02x' % t\n</code></pre>"},{"location":"tree/","title":"Tree","text":""},{"location":"tree/#backend.tree.Tree","title":"<code>Tree</code>","text":"<p>This is the main way to modify the pixels on the tree.</p> <p>To use in your file, import as follows:   from tree import tree</p> <p>After this, you can modify the pixels on the tree as such:   def main():     for pixel in tree.pixels:       pixel.set_rgb(0, 0, 0)</p> <p>Attributes:</p> Name Type Description <code>pixels</code> <code>list[Pixel]</code> <p>list[Pixel]: Pixel buffer held by the tree. Gets pushed to pixel driver on every update. The arry is in the same order as the lights on the strip</p> <code>coords</code> <p>list[tuple[float, float, float]]: A list of 3d coordinates (x,y,z) which is in ordeer of pixels on the strip i.e. parrallel with tree.pixels</p> <code>num_pixels</code> <p>int: The number of pixels on the tree. Same as doing len(tree.pixels)</p> <code>height</code> <p>float: Height of the tree</p> <code>distances</code> <p>list[list[float]]: A 2d array which holds pre-computed 3D euclidean distances between all pairs of pixels. The index of each array is parrallel with tree.pixels</p> Source code in <code>backend\\tree.py</code> <pre><code>class Tree():\n    \"\"\"This is the main way to modify the pixels on the tree.\n\n\n       To use in your file, import as follows:\n         from tree import tree\n\n       After this, you can modify the pixels on the tree as such:\n         def main():\n           for pixel in tree.pixels:\n             pixel.set_rgb(0, 0, 0)\n\n       Attributes:\n         pixels: list[Pixel]: Pixel buffer held by the tree. Gets pushed to pixel driver on every update. The arry is in the same order as the lights on the strip\n         coords: list[tuple[float, float, float]]: A list of 3d coordinates (x,y,z) which is in ordeer of pixels on the strip i.e. parrallel with tree.pixels\n         num_pixels: int: The number of pixels on the tree. Same as doing len(tree.pixels)\n         height: float: Height of the tree\n         distances: list[list[float]]: A 2d array which holds pre-computed 3D euclidean distances between all pairs of pixels. The index of each array is parrallel with tree.pixels\n    \"\"\"\n\n    def __init__(self):\n        self.fps = 45\n\n        self.coords = read_tree_csv()\n\n        self.num_pixels = int(len(self.coords))\n\n        # create a 10 frame buffer to the pixel driver\n        self.frame_queue: multiprocessing.Queue[Optional[tuple[int, list[int]]]] = multiprocessing.Queue(10)\n\n        # select the correct pixel driver for the system, either physical or sim\n        driver = pick_driver(self.num_pixels)\n        self.pixel_driver = driver(self.frame_queue, self.coords)\n\n        self.height = max([x[2] for x in self.coords])\n\n        self.distances = generate_distance_map(self.coords)\n\n        self.pixels: list[Pixel] = [Pixel((x[0], x[1], x[2])) for x in self.coords]\n\n        self.last_update = time.perf_counter()\n        self.render_times: list[float] = []\n\n        self.stop_flag = False\n\n    def set_light(self, n: int, color: Color):\n        \"\"\"Set the Nth light in the strip to the specified color\n\n        Args:\n            n (int): The light you want to set\n            color (Color): The color that you want to set the light to\n        \"\"\"\n        self.pixels[n].set_color(color)\n\n    def get_light(self, n: int) -&gt; Pixel:\n        \"\"\"Get the Nth light on the strip\n\n        Args:\n            n (int): The light you want to retrieve\n\n        Returns:\n            Pixel: The light that you have requested. You can then set the color of it directly\n        \"\"\"\n        return self.pixels[n]\n\n    def update(self):\n        \"\"\"This pushes the pixel buffer to the pixel driver, for pc use this pushes\n           the buffer to the pygame+openGL simulator , when ran on a raspberry pi it\n           will push it to the LED strip\n\n           Update also regulates the frame rate; typically the tree will\n           target 45 fps, if your pattern runs faster than 22ms it will sleep the\n           rest of the time until its time to generate a new frame. This shouldn't\n           affect the end developer, as they should just think of the main while\n           loop running every 22ms\n\n        Raises:\n            STOPFLAG\n        \"\"\"\n        t = time.perf_counter()\n        render_time = t - self.last_update\n        self.render_times.append(render_time)\n\n        # add frame to frame queue, if frame queue is full, then this blocks until space\n        self.frame_queue.put((self.fps, list(map(lambda x: x.to_int(), self.pixels))))\n\n        if self.stop_flag:\n            raise STOPFLAG(\"cancel\")\n\n        if len(self.render_times) &gt; 100:\n            self.render_times.pop(0)\n\n        if len(self.render_times) != 0:\n            avgrender = sum(self.render_times) / len(self.render_times)\n\n            if avgrender != 0:\n                print(f\"render: {str(avgrender*1000)[0:5]}ms ps: {round((avgrender / (1/tree.fps))*100, 2)}%       \", end=\"\\r\")\n        self.last_update = time.perf_counter()\n\n    def set_fps(self, fps: int):\n        \"\"\"Allows you to change the speed that you want the animation to run at.\n           If unset, the default fps is 45\n\n        Args:\n            fps (int): target fps for the animation.\n        \"\"\"\n        self.fps = fps\n\n    def run(self):\n        \"\"\"Internal\n        \"\"\"\n        process = multiprocessing.Process(target=self.pixel_driver.run, args=())\n        process.start()\n\n    def fade(self, n: float = 1.1):\n        \"\"\"Fade the entire tree.\n           n&lt;1 will cause the tree to become brighter.\n           tree.lerp(0, 0, 0) is prefered to tree.fade() as it if more performant\n           and gived better cotnrol over timing.\n\n        Args:\n            n (float, optional): Unknown. Defaults to 1.1.\n        \"\"\"\n        for pixel in self.pixels:\n            pixel.fade(n)\n\n    def black(self):\n        \"\"\"Sets all pixels on the tree to black (0, 0, 0)\n        \"\"\"\n        for pixel in self.pixels:\n            pixel.set_rgb(0, 0, 0)\n\n    def fill(self, color: Color):\n        \"\"\"Set all lights on the tree to one color\n\n        Args:\n            color (Color): The color you want to set the tree to\n        \"\"\"\n        for pixel in self.pixels:\n            pixel.set_color(color)\n\n    def lerp(self, color: Color, frames: int, fn: Callable[[float], float] = linear):\n        \"\"\"Lerp the entire tree from its current color to the target color over the specified amount of frames\n\n        Args:\n            color (Color): Target color\n            frames (int): The number of frames to perform the lerp over\n            fn (Callable[[float], float], optional): Timing function from the Util module. Defaults to linear.\n        \"\"\"\n        for pixel in self.pixels:\n            pixel.lerp(color.to_tuple(), frames, fn=fn)\n\n    def sleep(self, frames: int, allow_lerp: bool = False):\n        \"\"\"_summary_\n\n        Args:\n            frames (int): _description_\n            allow_lerp (bool, optional): _description_. Defaults to False.\n        \"\"\"\n        for _ in range(frames):\n            if allow_lerp:\n                for pixel in tree.pixels:\n                    pixel.cont_lerp()\n            self.update()\n</code></pre>"},{"location":"tree/#backend.tree.Tree.black","title":"<code>black()</code>","text":"<p>Sets all pixels on the tree to black (0, 0, 0)</p> Source code in <code>backend\\tree.py</code> <pre><code>def black(self):\n    \"\"\"Sets all pixels on the tree to black (0, 0, 0)\n    \"\"\"\n    for pixel in self.pixels:\n        pixel.set_rgb(0, 0, 0)\n</code></pre>"},{"location":"tree/#backend.tree.Tree.fade","title":"<code>fade(n=1.1)</code>","text":"<p>Fade the entire tree.    n&lt;1 will cause the tree to become brighter.    tree.lerp(0, 0, 0) is prefered to tree.fade() as it if more performant    and gived better cotnrol over timing.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>Unknown. Defaults to 1.1.</p> <code>1.1</code> Source code in <code>backend\\tree.py</code> <pre><code>def fade(self, n: float = 1.1):\n    \"\"\"Fade the entire tree.\n       n&lt;1 will cause the tree to become brighter.\n       tree.lerp(0, 0, 0) is prefered to tree.fade() as it if more performant\n       and gived better cotnrol over timing.\n\n    Args:\n        n (float, optional): Unknown. Defaults to 1.1.\n    \"\"\"\n    for pixel in self.pixels:\n        pixel.fade(n)\n</code></pre>"},{"location":"tree/#backend.tree.Tree.fill","title":"<code>fill(color)</code>","text":"<p>Set all lights on the tree to one color</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color</code> <p>The color you want to set the tree to</p> required Source code in <code>backend\\tree.py</code> <pre><code>def fill(self, color: Color):\n    \"\"\"Set all lights on the tree to one color\n\n    Args:\n        color (Color): The color you want to set the tree to\n    \"\"\"\n    for pixel in self.pixels:\n        pixel.set_color(color)\n</code></pre>"},{"location":"tree/#backend.tree.Tree.get_light","title":"<code>get_light(n)</code>","text":"<p>Get the Nth light on the strip</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The light you want to retrieve</p> required <p>Returns:</p> Name Type Description <code>Pixel</code> <code>Pixel</code> <p>The light that you have requested. You can then set the color of it directly</p> Source code in <code>backend\\tree.py</code> <pre><code>def get_light(self, n: int) -&gt; Pixel:\n    \"\"\"Get the Nth light on the strip\n\n    Args:\n        n (int): The light you want to retrieve\n\n    Returns:\n        Pixel: The light that you have requested. You can then set the color of it directly\n    \"\"\"\n    return self.pixels[n]\n</code></pre>"},{"location":"tree/#backend.tree.Tree.lerp","title":"<code>lerp(color, frames, fn=linear)</code>","text":"<p>Lerp the entire tree from its current color to the target color over the specified amount of frames</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color</code> <p>Target color</p> required <code>frames</code> <code>int</code> <p>The number of frames to perform the lerp over</p> required <code>fn</code> <code>Callable[[float], float]</code> <p>Timing function from the Util module. Defaults to linear.</p> <code>linear</code> Source code in <code>backend\\tree.py</code> <pre><code>def lerp(self, color: Color, frames: int, fn: Callable[[float], float] = linear):\n    \"\"\"Lerp the entire tree from its current color to the target color over the specified amount of frames\n\n    Args:\n        color (Color): Target color\n        frames (int): The number of frames to perform the lerp over\n        fn (Callable[[float], float], optional): Timing function from the Util module. Defaults to linear.\n    \"\"\"\n    for pixel in self.pixels:\n        pixel.lerp(color.to_tuple(), frames, fn=fn)\n</code></pre>"},{"location":"tree/#backend.tree.Tree.run","title":"<code>run()</code>","text":"<p>Internal</p> Source code in <code>backend\\tree.py</code> <pre><code>def run(self):\n    \"\"\"Internal\n    \"\"\"\n    process = multiprocessing.Process(target=self.pixel_driver.run, args=())\n    process.start()\n</code></pre>"},{"location":"tree/#backend.tree.Tree.set_fps","title":"<code>set_fps(fps)</code>","text":"<p>Allows you to change the speed that you want the animation to run at.    If unset, the default fps is 45</p> <p>Parameters:</p> Name Type Description Default <code>fps</code> <code>int</code> <p>target fps for the animation.</p> required Source code in <code>backend\\tree.py</code> <pre><code>def set_fps(self, fps: int):\n    \"\"\"Allows you to change the speed that you want the animation to run at.\n       If unset, the default fps is 45\n\n    Args:\n        fps (int): target fps for the animation.\n    \"\"\"\n    self.fps = fps\n</code></pre>"},{"location":"tree/#backend.tree.Tree.set_light","title":"<code>set_light(n, color)</code>","text":"<p>Set the Nth light in the strip to the specified color</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The light you want to set</p> required <code>color</code> <code>Color</code> <p>The color that you want to set the light to</p> required Source code in <code>backend\\tree.py</code> <pre><code>def set_light(self, n: int, color: Color):\n    \"\"\"Set the Nth light in the strip to the specified color\n\n    Args:\n        n (int): The light you want to set\n        color (Color): The color that you want to set the light to\n    \"\"\"\n    self.pixels[n].set_color(color)\n</code></pre>"},{"location":"tree/#backend.tree.Tree.sleep","title":"<code>sleep(frames, allow_lerp=False)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>int</code> <p>description</p> required <code>allow_lerp</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> Source code in <code>backend\\tree.py</code> <pre><code>def sleep(self, frames: int, allow_lerp: bool = False):\n    \"\"\"_summary_\n\n    Args:\n        frames (int): _description_\n        allow_lerp (bool, optional): _description_. Defaults to False.\n    \"\"\"\n    for _ in range(frames):\n        if allow_lerp:\n            for pixel in tree.pixels:\n                pixel.cont_lerp()\n        self.update()\n</code></pre>"},{"location":"tree/#backend.tree.Tree.update","title":"<code>update()</code>","text":"<p>This pushes the pixel buffer to the pixel driver, for pc use this pushes    the buffer to the pygame+openGL simulator , when ran on a raspberry pi it    will push it to the LED strip</p> <p>Update also regulates the frame rate; typically the tree will    target 45 fps, if your pattern runs faster than 22ms it will sleep the    rest of the time until its time to generate a new frame. This shouldn't    affect the end developer, as they should just think of the main while    loop running every 22ms</p> Source code in <code>backend\\tree.py</code> <pre><code>def update(self):\n    \"\"\"This pushes the pixel buffer to the pixel driver, for pc use this pushes\n       the buffer to the pygame+openGL simulator , when ran on a raspberry pi it\n       will push it to the LED strip\n\n       Update also regulates the frame rate; typically the tree will\n       target 45 fps, if your pattern runs faster than 22ms it will sleep the\n       rest of the time until its time to generate a new frame. This shouldn't\n       affect the end developer, as they should just think of the main while\n       loop running every 22ms\n\n    Raises:\n        STOPFLAG\n    \"\"\"\n    t = time.perf_counter()\n    render_time = t - self.last_update\n    self.render_times.append(render_time)\n\n    # add frame to frame queue, if frame queue is full, then this blocks until space\n    self.frame_queue.put((self.fps, list(map(lambda x: x.to_int(), self.pixels))))\n\n    if self.stop_flag:\n        raise STOPFLAG(\"cancel\")\n\n    if len(self.render_times) &gt; 100:\n        self.render_times.pop(0)\n\n    if len(self.render_times) != 0:\n        avgrender = sum(self.render_times) / len(self.render_times)\n\n        if avgrender != 0:\n            print(f\"render: {str(avgrender*1000)[0:5]}ms ps: {round((avgrender / (1/tree.fps))*100, 2)}%       \", end=\"\\r\")\n    self.last_update = time.perf_counter()\n</code></pre>"},{"location":"Examples/","title":"Examples","text":"<p>This section of the documentation contains example code which shows you how to use the basic functions of the Tree.</p>"},{"location":"Examples/black/","title":"Tree.black()","text":"<p>Sets all pixels on the tree to black (0, 0, 0)</p> Source code in <code>backend\\tree.py</code> <pre><code>def black(self):\n    \"\"\"Sets all pixels on the tree to black (0, 0, 0)\n    \"\"\"\n    for pixel in self.pixels:\n        pixel.set_rgb(0, 0, 0)\n</code></pre> <p> Example Usage:</p> <pre><code>from tree import tree\n\nname = \"Set to black Example\"\nauthor = \"Owen\"\n\ndef run():\n    while True:\n        tree.black() # Set all pixels to black (off)\n\n        tree.update() # Push the pixels onto the tree\n</code></pre>"},{"location":"Examples/fill/","title":"Tree.fill()","text":"<p>Set all lights on the tree to one color</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Color</code> <p>The color you want to set the tree to</p> required Source code in <code>backend\\tree.py</code> <pre><code>def fill(self, color: Color):\n    \"\"\"Set all lights on the tree to one color\n\n    Args:\n        color (Color): The color you want to set the tree to\n    \"\"\"\n    for pixel in self.pixels:\n        pixel.set_color(color)\n</code></pre> <p> Example Usage:</p> <pre><code>from tree import tree\nfrom color import Color\n\nname = \"Fill Example\"\nauthor = \"Owen\"\n\ndef run():\n    while True:\n        tree.fill(Color.blue()) # Set all pixels on the tree to blue\n\n        tree.update() # Push the pixels onto the tree\n</code></pre>"},{"location":"Examples/set_light/","title":"Tree.set_light()","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>int</code> <p>description</p> required <code>allow_lerp</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> Source code in <code>backend\\tree.py</code> <pre><code>def sleep(self, frames: int, allow_lerp: bool = False):\n    \"\"\"_summary_\n\n    Args:\n        frames (int): _description_\n        allow_lerp (bool, optional): _description_. Defaults to False.\n    \"\"\"\n    for _ in range(frames):\n        if allow_lerp:\n            for pixel in tree.pixels:\n                pixel.cont_lerp()\n        self.update()\n</code></pre> <p> Example Usage:</p> <pre><code>from tree import tree\nfrom color import Color\n\nname = \"Set Light Example\"\nauthor = \"Owen\"\n\ndef run():\n    while True:\n        tree.set_light(10, Color(255, 255, 0)) # Set the 10th light on the tree to orange\n\n        tree.update() # Push the pixels onto the tree\n</code></pre>"},{"location":"Examples/sleep/","title":"Tree.sleep()","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>int</code> <p>description</p> required <code>allow_lerp</code> <code>bool</code> <p>description. Defaults to False.</p> <code>False</code> Source code in <code>backend\\tree.py</code> <pre><code>def sleep(self, frames: int, allow_lerp: bool = False):\n    \"\"\"_summary_\n\n    Args:\n        frames (int): _description_\n        allow_lerp (bool, optional): _description_. Defaults to False.\n    \"\"\"\n    for _ in range(frames):\n        if allow_lerp:\n            for pixel in tree.pixels:\n                pixel.cont_lerp()\n        self.update()\n</code></pre> <p> Example Usage:</p> <pre><code>from tree import tree\nfrom color import Color\n\nname = \"Sleep Example\"\nauthor = \"Owen\"\n\ndef run():\n    while True:\n        tree.fill(Color(255, 0, 0)) # Set the entire tree to red\n        tree.update() # Push the pixels onto the tree\n\n        tree.fill(Color(0, 0, 255)) # Set the entire tree to blue\n\n        tree.sleep(45) # Pause the pattern for 45 frames. At default frame rate, this is 1 second\n\n        tree.update() # Push the pixels onto the tree\n</code></pre>"},{"location":"Examples/update/","title":"Tree.update()","text":"<p>This pushes the pixel buffer to the pixel driver, for pc use this pushes    the buffer to the pygame+openGL simulator , when ran on a raspberry pi it    will push it to the LED strip</p> <p>Update also regulates the frame rate; typically the tree will    target 45 fps, if your pattern runs faster than 22ms it will sleep the    rest of the time until its time to generate a new frame. This shouldn't    affect the end developer, as they should just think of the main while    loop running every 22ms</p> Source code in <code>backend\\tree.py</code> <pre><code>def update(self):\n    \"\"\"This pushes the pixel buffer to the pixel driver, for pc use this pushes\n       the buffer to the pygame+openGL simulator , when ran on a raspberry pi it\n       will push it to the LED strip\n\n       Update also regulates the frame rate; typically the tree will\n       target 45 fps, if your pattern runs faster than 22ms it will sleep the\n       rest of the time until its time to generate a new frame. This shouldn't\n       affect the end developer, as they should just think of the main while\n       loop running every 22ms\n\n    Raises:\n        STOPFLAG\n    \"\"\"\n    t = time.perf_counter()\n    render_time = t - self.last_update\n    self.render_times.append(render_time)\n\n    # add frame to frame queue, if frame queue is full, then this blocks until space\n    self.frame_queue.put((self.fps, list(map(lambda x: x.to_int(), self.pixels))))\n\n    if self.stop_flag:\n        raise STOPFLAG(\"cancel\")\n\n    if len(self.render_times) &gt; 100:\n        self.render_times.pop(0)\n\n    if len(self.render_times) != 0:\n        avgrender = sum(self.render_times) / len(self.render_times)\n\n        if avgrender != 0:\n            print(f\"render: {str(avgrender*1000)[0:5]}ms ps: {round((avgrender / (1/tree.fps))*100, 2)}%       \", end=\"\\r\")\n    self.last_update = time.perf_counter()\n</code></pre> <p> Example Usage:</p> <pre><code>from tree import tree\n\nname = \"Update Example\"\nauthor = \"Ciaran\"\n\ndef run():\n    while True:\n        # Change tree pixels here\n\n        tree.update() # Push the pixels onto the tree\n</code></pre>"}]}